#----------------------------------------------------------------------------------------------#
#                                    Amount Type Interface                                     #
#----------------------------------------------------------------------------------------------#

"""
`function deco end`\n
Interface to return a unique decorative `Symbol` from a method's argument type.
"""
function deco end

"""
`function ppu end`\n
Interface to pretty-print units.
"""
function ppu end

# A 191113-212130 benchmark showed amt(x) is faster than x.amt:
#
# ```julia-repl
# julia> u1 = u(1.0f0 ¬± 0.1f0, MO)
# ≈´‚ÇÉ‚ÇÇ: (1 ¬± 0.1) kJ/kmol
#
# julia> typeof(u1)
# uAmt{Float32,MM,MO}
#
# julia> @benchmark u1.amt
# ‚úÇ ‚úÇ ‚úÇ   median time:      26.918 ns (0.00% GC)   ‚úÇ ‚úÇ ‚úÇ
#
# julia> @benchmark amt(u1)
# ‚úÇ ‚úÇ ‚úÇ   median time:      16.710 ns (0.00% GC)   ‚úÇ ‚úÇ ‚úÇ
#
# ```

"""
`function amt end`\n
Interface to get an `AMOUNTS`' `:amt` field in a type-stable manner.
"""
function amt end

export deco, ppu, amt


#----------------------------------------------------------------------------------------------#
#                                     Generic Amount Type                                      #
#----------------------------------------------------------------------------------------------#

import Base: cp, convert
import Unicode: normalize
import Base: +, -, *, /

"""
Generic Amount type factory.
"""
function mkGenAmt(TYPE::Symbol,         # Type name:            :_Amt
                  SUPT::Symbol,         # Supertype:            :GenerAmt
                  FNAM::Symbol,         # Function Name:        :_
                  SYMB::AbstractString, # Printing symbol:      "_"
                  WHAT::AbstractString, # Description:          "generic amounts"
                  DELT::Bool=false,     # Whether a Œî quantity
                 )
    # Constants
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = normalize((DELT ? "Œî" : "") * string(SYMB))
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC} <: $SUPT{ùóΩ,ùòÖ}`\n
Precision-, and Exactness- parametric $WHAT amounts based in arbitrary units.\n
`$TYPE{ùóΩ,ùòÖ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with any units.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    fnStr = "Function to return $WHAT amounts of arbitrary units."
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ} <: $SUPT{ùóΩ,ùòÖ}
            amt::UATY{ùóΩ} where ùóΩ<:PREC
            # Inner, non-converting, parameter-determining constructors
            $TYPE(x::$TYPE{ùóΩ,ùòÖ}) where {ùóΩ<:PREC,ùòÖ<:EXAC} = new{ùóΩ,ùòÖ}(amt(x))
            $TYPE(x::Union{ùóΩ,UETY{ùóΩ}}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x))
            $TYPE(x::Union{PMTY{ùóΩ},UMTY{ùóΩ}}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x))
            # Inner, non-converting, fully-specified constructors
            (::Type{$TYPE{ùóΩ,EX}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x))
            (::Type{$TYPE{ùóΩ,EX}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x.val))
            (::Type{$TYPE{ùóΩ,MM}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(measurement(x)))
            (::Type{$TYPE{ùóΩ,MM}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x))
        end
        # Type documentation
        @doc $dcStr $TYPE
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(ùòÄ(amt(x).val) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val) * unit(amt(x)))
        end
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(ùòÄ(amt(x).val) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(ùòÄ(amt(x).val.val) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX},
                              e::ùòÄ=ùòÄ(max(eps(ùòÄ), eps(amt(x).val)))) where {ùòÄ<:PREC,
                                                                           ùóΩ<:PREC} = begin
            $TYPE(measurement(ùòÄ(amt(x).val), e) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val) * unit(amt(x)))
        end
        # Type export
        export $TYPE
        # Type-stabler wrapped amount obtaining function
        amt(x::$TYPE{ùóΩ,EX}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ}
        amt(x::$TYPE{ùóΩ,MM}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ}}
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        ppu(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = string(unit(amt(x)))
        # Function interface
        function $FNAM end
        @doc $fnStr $FNAM
        # Indirect construction from plain
        $FNAM(x::plnF) = $TYPE(x)
        $FNAM(x::REAL) = $TYPE(float(x))
        # Indirect construction from quantity
        $FNAM(x::UATY{ùóΩ}) where ùóΩ<:PREC = $TYPE(x)
        $FNAM(x::uniR{ùóΩ}) where ùóΩ<:REAL = $TYPE(float(x.val) * unit(x))
        # Indirect construction from another AMOUNTS
        $FNAM(x::AMOUNTS) = $TYPE(amt(x)) # AMOUNTS fallback
        # Function export
        export $FNAM
        # Conversions
        convert(::Type{$TYPE{ùòÄ,ùòÖ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        convert(::Type{$TYPE{ùòÄ,ùòÜ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}
        end
        # same-type sum,sub with Unitful promotion
        +(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(+(amt(x), amt(y)))
        end
        -(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(-(amt(x), amt(y)))
        end
        # scalar mul,div with Unitful promotion
        *(y::plnF{ùòÄ}, x::$TYPE{ùóΩ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        *(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        /(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(/(amt(x), y))
        # Type-preserving scalar mul,div
        *(y::REAL, x::$TYPE{ùóΩ}) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        *(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        /(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(/(amt(x), ùóΩ(y)))
    end
end

#----------------------------------------------------------------------------------------------#
#                                 Generic Amount Declarations                                  #
#----------------------------------------------------------------------------------------------#

# The fallback generic amount
mkGenAmt(:_Amt, :GenerAmt, :_a, "_", "generic", false)


#----------------------------------------------------------------------------------------------#
#                                  Whole Amount Type Factory                                   #
#----------------------------------------------------------------------------------------------#

"""
Whole Amount type factory.
"""
function mkWhlAmt(TYPE::Symbol,         # Type name:            :sysT
                  SUPT::Symbol,         # Supertype:            :WProperty
                  FNAM::Symbol,         # Function Name:        :T
                  SYMB::AbstractString, # Printing symbol:      "T"
                  UNIT::Unitful.Units,  # SY quantity units:    u"K"
                  USTR::AbstractString, # PrettyPrinting units: "K"
                  WHAT::AbstractString, # Description:          "temperature"
                  DELT::Bool=false,     # Whether a Œî quantity
                 )
    # Constants
    uSY = UNIT
    ùë¢SY = typeof(uSY)
    ùëëSY = dimension(uSY)
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = normalize((DELT ? "Œî" : "") * string(SYMB))
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC} <: $SUPT{ùóΩ,ùòÖ}`\n
Precision-, and Exactness- parametric $WHAT amounts based in $USTR.\n
`$TYPE{ùóΩ,ùòÖ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with compatible units.\n
Constructors determine all parameters from their arguments.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    fnStr = "Function to return $WHAT amounts in ($USTR)."
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ} <: $SUPT{ùóΩ,ùòÖ}
            amt::UATY{ùóΩ,$ùëëSY,$ùë¢SY} where ùóΩ<:PREC
            # Inner, non-converting, parameter-determining constructors
            # ---------------------------------------------------------
            # Copy constructor
            $TYPE(x::$TYPE{ùóΩ,ùòÖ}) where {ùóΩ<:PREC,ùòÖ<:EXAC} = new{ùóΩ,ùòÖ}(amt(x))
            # Plain constructors enforce default units & avoid unit conversion
            $TYPE(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x * $uSY))
            $TYPE(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x * $uSY))
            # Quantity constructors have to perform unit conversion despite matching dimensions
            $TYPE(x::UETY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(uconvert($uSY, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(uconvert($uSY, x)))
            # Inner, non-converting, fully-specified constructors
            # ---------------------------------------------------
            (::Type{$TYPE{ùóΩ,EX}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x * $uSY))
            (::Type{$TYPE{ùóΩ,EX}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x.val * $uSY))
            (::Type{$TYPE{ùóΩ,MM}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(measurement(x) * $uSY))
            (::Type{$TYPE{ùóΩ,MM}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x * $uSY))
        end
        # Type documentation
        @doc $dcStr $TYPE
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX}
                          ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(amt(x).val))
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM}
                          ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(Measurement{ùòÄ}(amt(x).val))
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(amt(x).val))
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(amt(x).val.val))
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX},
                              e::ùòÄ=ùòÄ(max(eps(ùòÄ),eps(amt(x).val)))
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(measurement(ùòÄ(amt(x).val), e))
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(Measurement{ùòÄ}(amt(x).val))
        # Type export
        export $TYPE
        # Type-stable wrapped amount obtaining function
        amt(x::$TYPE{ùóΩ,EX}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëSY,$ùë¢SY}
        amt(x::$TYPE{ùóΩ,MM}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëSY,$ùë¢SY}
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        ppu(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = $USTR
        # Function interface
        function $FNAM end
        @doc $fnStr $FNAM
        # Indirect construction from plain
        $FNAM(x::plnF) = $TYPE(x)
        $FNAM(x::REAL) = $TYPE(float(x))
        # Indirect construction from quantity
        $FNAM(x::UATY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = $TYPE(x)
        $FNAM(x::uniR{ùóΩ,$ùëëSY}) where ùóΩ<:REAL = $TYPE(float(x.val) * unit(x))
        # Indirect construction from another AMOUNTS
        $FNAM(x::AMOUNTS) = $TYPE(amt(x)) # AMOUNTS fallback
        # Function export
        export $FNAM
        # Conversions
        convert(::Type{$TYPE{ùòÄ,ùòÖ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        convert(::Type{$TYPE{ùòÄ,ùòÜ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}
        end
        # same-type sum,sub with Unitful promotion
        +(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(+(amt(x), amt(y)))
        end
        -(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(-(amt(x), amt(y)))
        end
        # scalar mul,div with Unitful promotion
        *(y::plnF{ùòÄ}, x::$TYPE{ùóΩ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        *(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        /(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(/(amt(x), y))
        # Type-preserving scalar mul,div
        *(y::REAL, x::$TYPE{ùóΩ}) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        *(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        /(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(/(amt(x), ùóΩ(y)))
    end
end


#----------------------------------------------------------------------------------------------#
#                           Thermodynamic Whole Amount Declarations                            #
#----------------------------------------------------------------------------------------------#

# Regular properties -- \bb#<TAB> velocity/speed function names
mkWhlAmt(:sysT, :WProperty, :T   , "T", u"K"       , "K"       , "temperature", false)
mkWhlAmt(:sysP, :WProperty, :P   , "P", u"kPa"     , "kPa"     , "pressure"   , false)
mkWhlAmt(:VELO, :WProperty, :velo, "ùïç", u"‚àö(kJ/kg)", "‚àö(kJ/kg)", "velocity"   , false)
mkWhlAmt(:SPEE, :WProperty, :spee, "ùïß", u"m/s"     , "m/s"     , "speed"      , false)

# Regular unranked -- \sans#<TAB> function names
mkWhlAmt(:TIME, :WUnranked, :t   , "ùóç", u"s"       , "s"       , "time"       , false)
mkWhlAmt(:GRAV, :WUnranked, :grav, "ùíà", u"m/s^2"   , "m/s¬≤"    , "gravity"    , false)
mkWhlAmt(:zAmt, :WUnranked, :z   , "ùóì", u"m"       , "m"       , "altitude"   , false)

# Derived thermodynamic properties
mkWhlAmt(:ZAmt , :WProperty, :Z   , "Z"  , ULESS()    , "‚Äì"       , "generalized compressibility factor", false)
mkWhlAmt(:Œ≥Amt , :WProperty, :Œ≥   , "Œ≥"  , ULESS()    , "‚Äì"       , "specific heat ratio"               , false)
mkWhlAmt(:Œ≤Amt , :WProperty, :Œ≤   , "Œ≤"  , inv(u"K")  , "/K"      , "coefficient of volume expansion"   , false)
mkWhlAmt(:Œ∫TAmt, :WProperty, :Œ∫T  , "Œ∫T" , inv(u"kPa"), "/kPa"    , "isothermal compressibility"        , false)
mkWhlAmt(:Œ∫sAmt, :WProperty, :Œ∫s  , "Œ∫s" , inv(u"kPa"), "/kPa"    , "isentropic compressibility"        , false)
mkWhlAmt(:kAmt , :WProperty, :k   , "k"  , ULESS()    , "‚Äì"       , "isentropic expansion exponent"     , false)
mkWhlAmt(:ùïîAmt , :WProperty, :ùïî   , "ùïî"  , u"‚àö(kJ/kg)", "‚àö(kJ/kg)", "adiabatic speed of sound"          , false)
mkWhlAmt(:MaAmt, :WProperty, :Ma  , "Ma" , ULESS()    , "‚Äì"       , "Mach number"                       , false)
mkWhlAmt(:ŒºJAmt, :WProperty, :ŒºJT , "ŒºJT", u"K/kPa"   , "K/kPa"   , "Joule-Thomson coefficient"         , false)
mkWhlAmt(:ŒºSAmt, :WProperty, :ŒºS  , "ŒºS" , u"K/kPa"   , "K/kPa"   , "isentropic expansion coefficient"  , false)
mkWhlAmt(:xAmt , :WProperty, :x   , "x"  , ULESS()    , "‚Äì"       , "saturated vapor mass fraction"     , false)
mkWhlAmt(:PrAmt, :WProperty, :Pr  , "Pr" , ULESS()    , "‚Äì"       , "relative pressure"                 , false)
mkWhlAmt(:vrAmt, :WProperty, :vr  , "vr" , ULESS()    , "‚Äì"       , "relative specific volume"          , false)

# Generic dimensionless ratio
mkWhlAmt(:√∏Amt , :WProperty, :√∏   , "√∏"  , ULESS()    , "‚Äì"       , "generic dimensionless ratio"       , false)


#----------------------------------------------------------------------------------------------#
#                                  Based Amount Type Factory                                   #
#----------------------------------------------------------------------------------------------#

"""
Based Amount type factory.
"""
function mkBasAmt(TYPE::Symbol,         # Type Name:            :uAmt
                  SUPT::Symbol,         # Supertype:            :BProperty
                  FNAM::Symbol,         # Function Name:        :u
                  SYMB::AbstractString, # Printing symbol:      "U"
                  UNIT::Unitful.Units,  # SY quantity units:    u"kJ"
                  USTR::AbstractString, # PrettyPrinting units: "K"
                  WHAT::AbstractString, # Description:          "internal energy"
                  DELT::Bool=false;     # Whether a Œî quantity
                  bsym::NTuple{4,Symbol}=(:none,:none,:none,:none)
                 )
    # Constants
    uSY = UNIT
    uDT = UNIT / u"s"
    uMA = UNIT / u"kg"
    uMO = UNIT / u"kmol"
    ùë¢SY = typeof(uSY)
    ùë¢DT = typeof(uDT)
    ùë¢MA = typeof(uMA)
    ùë¢MO = typeof(uMO)
    ùëëSY = dimension(uSY)
    ùëëDT = dimension(uDT)
    ùëëMA = dimension(uMA)
    ùëëMO = dimension(uMO)
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = bsym[1] == :none ?
        normalize((DELT ? "Œî" : "") * uppercase(string(SYMB))) :
        string(bsym[1])
    ùë†DT = bsym[2] == :none ?
        normalize(string(ùë†SY[1:i], "\u0307", ùë†SY[f:end])) :
        string(bsym[2])
    ùë†MA = bsym[3] == :none ?
        normalize((DELT ? "Œî" : "") * lowercase(string(SYMB))) :
        string(bsym[3])
    ùë†MO = bsym[4] == :none ?
        normalize(string(ùë†MA[1:i], "\u0304", ùë†MA[f:end])) :
        string(bsym[4])
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} <: $SUPT{ùóΩ,ùòÖ,ùóØ}`\n
Precision-, Exactness-, and Base- parametric $WHAT amounts based in $USTR.\n
`$TYPE{ùóΩ,ùòÖ,ùóØ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
- Thermodynamic base `ùóØ<:Union{SY,DT,MA,MO}` respectively for system, rate, mass, or molar
  quantities, respectively in units of $(uSY), $(uDT), $(uMA), or $(uMO).\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with compatible units.\n
Constructors determine parameters from their arguments. `Quantity` constructors do not need a
base argument. Plain, `AbstractFloat` ones require the base argument.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    fnStr = "Function to return $WHAT amounts in ($USTR)."
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ,ùóØ} <: $SUPT{ùóΩ,ùòÖ,ùóØ}
            amt::Union{UATY{ùóΩ,$ùëëSY,$ùë¢SY},UATY{ùóΩ,$ùëëDT,$ùë¢DT},
                       UATY{ùóΩ,$ùëëMA,$ùë¢MA},UATY{ùóΩ,$ùëëMO,$ùë¢MO}} where ùóΩ<:PREC
            # Inner, non-converting, parameter-determining constructors
            # ---------------------------------------------------------
            # Copy constructor
            $TYPE(x::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} = new{ùóΩ,ùòÖ,ùóØ}(amt(x))
            # Plain constructors enforce default units & avoid unit conversion
            # Plain Exact (ùóΩ<:PREC) float constructors
            $TYPE(x::ùóΩ, ::Type{SY}) where ùóΩ<:PREC = new{ùóΩ,EX,SY}(_qty(x * $uSY))
            $TYPE(x::ùóΩ, ::Type{DT}) where ùóΩ<:PREC = new{ùóΩ,EX,DT}(_qty(x * $uDT))
            $TYPE(x::ùóΩ, ::Type{MA}) where ùóΩ<:PREC = new{ùóΩ,EX,MA}(_qty(x * $uMA))
            $TYPE(x::ùóΩ, ::Type{MO}) where ùóΩ<:PREC = new{ùóΩ,EX,MO}(_qty(x * $uMO))
            # Plain Measurement (PMTY) constructors
            $TYPE(x::PMTY{ùóΩ}, ::Type{SY}) where ùóΩ<:PREC = new{ùóΩ,MM,SY}(_qty(x * $uSY))
            $TYPE(x::PMTY{ùóΩ}, ::Type{DT}) where ùóΩ<:PREC = new{ùóΩ,MM,DT}(_qty(x * $uDT))
            $TYPE(x::PMTY{ùóΩ}, ::Type{MA}) where ùóΩ<:PREC = new{ùóΩ,MM,MA}(_qty(x * $uMA))
            $TYPE(x::PMTY{ùóΩ}, ::Type{MO}) where ùóΩ<:PREC = new{ùóΩ,MM,MO}(_qty(x * $uMO))
            # Quantity constructors have to perform unit conversion despite matching dimensions
            # United Exact (UETY) constructors
            $TYPE(x::UETY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,EX,SY}(_qty(uconvert($uSY, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëDT}) where ùóΩ<:PREC = new{ùóΩ,EX,DT}(_qty(uconvert($uDT, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëMA}) where ùóΩ<:PREC = new{ùóΩ,EX,MA}(_qty(uconvert($uMA, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëMO}) where ùóΩ<:PREC = new{ùóΩ,EX,MO}(_qty(uconvert($uMO, x)))
            # United Measurement (UMTY) constructors
            $TYPE(x::UMTY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,MM,SY}(_qty(uconvert($uSY, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëDT}) where ùóΩ<:PREC = new{ùóΩ,MM,DT}(_qty(uconvert($uDT, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëMA}) where ùóΩ<:PREC = new{ùóΩ,MM,MA}(_qty(uconvert($uMA, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëMO}) where ùóΩ<:PREC = new{ùóΩ,MM,MO}(_qty(uconvert($uMO, x)))
            # Inner, non-converting, fully-specified constructors
            # ---------------------------------------------------
            # SY-based constructors
            (::Type{$TYPE{ùóΩ,EX,SY}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,SY}(_qty(             x * $uSY))
            end
            (::Type{$TYPE{ùóΩ,EX,SY}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,SY}(_qty(         x.val * $uSY))
            end
            (::Type{$TYPE{ùóΩ,MM,SY}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,SY}(_qty(measurement(x) * $uSY))
            end
            (::Type{$TYPE{ùóΩ,MM,SY}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,SY}(_qty(             x * $uSY))
            end
            # DT-based constructors
            (::Type{$TYPE{ùóΩ,EX,DT}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,DT}(_qty(             x * $uDT))
            end
            (::Type{$TYPE{ùóΩ,EX,DT}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,DT}(_qty(         x.val * $uDT))
            end
            (::Type{$TYPE{ùóΩ,MM,DT}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,DT}(_qty(measurement(x) * $uDT))
            end
            (::Type{$TYPE{ùóΩ,MM,DT}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,DT}(_qty(             x * $uDT))
            end
            # MA-based constructors
            (::Type{$TYPE{ùóΩ,EX,MA}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MA}(_qty(             x * $uMA))
            end
            (::Type{$TYPE{ùóΩ,EX,MA}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MA}(_qty(         x.val * $uMA))
            end
            (::Type{$TYPE{ùóΩ,MM,MA}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MA}(_qty(measurement(x) * $uMA))
            end
            (::Type{$TYPE{ùóΩ,MM,MA}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MA}(_qty(             x * $uMA))
            end
            # MO-based constructors
            (::Type{$TYPE{ùóΩ,EX,MO}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MO}(_qty(             x * $uMO))
            end
            (::Type{$TYPE{ùóΩ,EX,MO}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MO}(_qty(         x.val * $uMO))
            end
            (::Type{$TYPE{ùóΩ,MM,MO}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MO}(_qty(measurement(x) * $uMO))
            end
            (::Type{$TYPE{ùóΩ,MM,MO}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MO}(_qty(             x * $uMO))
            end
        end
        # Type documentation
        @doc $dcStr $TYPE
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(amt(x).val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val), ùóØ)
        end
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(amt(x).val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(amt(x).val.val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX,ùóØ},
                            e::ùòÄ=ùòÄ(max(eps(ùòÄ),eps(amt(x).val)))
                            ) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(measurement(ùòÄ(amt(x).val), e), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val), ùóØ)
        end
        # Type export
        export $TYPE
        # Type-stable wrapped amount obtaining function
        amt(x::$TYPE{ùóΩ,EX,SY}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëSY,$ùë¢SY}
        amt(x::$TYPE{ùóΩ,EX,DT}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëDT,$ùë¢DT}
        amt(x::$TYPE{ùóΩ,EX,MA}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëMA,$ùë¢MA}
        amt(x::$TYPE{ùóΩ,EX,MO}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëMO,$ùë¢MO}
        amt(x::$TYPE{ùóΩ,MM,SY}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëSY,$ùë¢SY}
        amt(x::$TYPE{ùóΩ,MM,DT}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëDT,$ùë¢DT}
        amt(x::$TYPE{ùóΩ,MM,MA}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëMA,$ùë¢MA}
        amt(x::$TYPE{ùóΩ,MM,MO}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëMO,$ùë¢MO}
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ,SY} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        deco(x::$TYPE{ùóΩ,ùòÖ,DT} where {ùóΩ,ùòÖ}) = Symbol($ùë†DT)
        deco(x::$TYPE{ùóΩ,ùòÖ,MA} where {ùóΩ,ùòÖ}) = Symbol($ùë†MA)
        deco(x::$TYPE{ùóΩ,ùòÖ,MO} where {ùóΩ,ùòÖ}) = Symbol($ùë†MO)
        ppu(x::$TYPE{ùóΩ,ùòÖ,SY} where {ùóΩ,ùòÖ}) = $USTR
        ppu(x::$TYPE{ùóΩ,ùòÖ,DT} where {ùóΩ,ùòÖ}) = $USTR * "/s"
        ppu(x::$TYPE{ùóΩ,ùòÖ,MA} where {ùóΩ,ùòÖ}) = $USTR * "/kg"
        ppu(x::$TYPE{ùóΩ,ùòÖ,MO} where {ùóΩ,ùòÖ}) = $USTR * "/kmol"
        # Function interface
        function $FNAM end
        @doc $fnStr $FNAM
        # Indirect construction from plain
        $FNAM(x::plnF, b::Type{ùóØ}=DEF[:IB]) where ùóØ<:BASE = $TYPE(x, b)
        $FNAM(x::REAL, b::Type{ùóØ}=DEF[:IB]) where ùóØ<:BASE = $TYPE(float(x), b)
        # Indirect construction from type
        $FNAM(x::$TYPE{ùóΩ,ùòÖ,ùóØ} where {ùóΩ,ùòÖ,ùóØ}) = x
        # Indirect construction from quantity
        $FNAM(x::Union{UATY{ùóΩ,$ùëëSY},UATY{ùóΩ,$ùëëDT},
                       UATY{ùóΩ,$ùëëMA},UATY{ùóΩ,$ùëëMO}}) where ùóΩ<:PREC = begin
            $TYPE(x)
        end
        $FNAM(x::Union{uniR{ùóΩ,$ùëëSY},uniR{ùóΩ,$ùëëDT},
                       uniR{ùóΩ,$ùëëMA},uniR{ùóΩ,$ùëëMO}}) where ùóΩ<:REAL = begin
            $TYPE(float(x.val) * unit(x))
        end
        # Indirect construction from another AMOUNTS
        $FNAM(x::AMOUNTS) = $FNAM(amt(x)) # AMOUNTS fallback
        # Function export
        export $FNAM
        # Conversions - Change of base is _not_ a conversion
        # Same {EXAC,BASE}, {PREC}- conversion
        convert(::Type{$TYPE{ùòÄ,ùòÖ,ùóØ}},
                y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        # Same {BASE}, {PREC,EXAC}- conversion
        convert(::Type{$TYPE{ùòÄ,ùòÜ,ùóØ}},
                y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ,ùóØ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ,ùóØ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,
                                                  ùòÜ<:EXAC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ),ùóØ}
        end
        # same-type sum,sub with Unitful promotion
        +(x::$TYPE{ùòÄ,ùòÜ,ùóØ}, y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,
                                                   ùòÜ<:EXAC,ùòÖ<:EXAC,
                                                   ùóØ<:BASE} = begin
            $TYPE(+(amt(x), amt(y)))
        end
        -(x::$TYPE{ùòÄ,ùòÜ,ùóØ}, y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,
                                                   ùòÜ<:EXAC,ùòÖ<:EXAC,
                                                   ùóØ<:BASE} = begin
            $TYPE(-(amt(x), amt(y)))
        end
        # scalar mul,div with Unitful promotion
        *(y::plnF{ùòÄ}, x::$TYPE{ùóΩ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        *(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        /(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(/(amt(x), y))
        # Type-preserving scalar mul,div
        *(y::REAL, x::$TYPE{ùóΩ}) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        *(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        /(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(/(amt(x), ùóΩ(y)))
    end
end


#----------------------------------------------------------------------------------------------#
#                           Thermodynamic Amount Group Declarations                            #
#----------------------------------------------------------------------------------------------#

# Mass / Mass fraction anomalous
mkBasAmt(:mAmt , :BProperty, :m , "m" , u"kg"  , "kg"  , "mass"               , false, bsym=(:m  , :mÃá  , :mf, :M ))
# Chemical amount / Molar fraction anomalous
mkBasAmt(:nAmt , :BProperty, :N , "N" , u"kmol", "kmol", "chemical amount"    , false, bsym=(:N  , :NÃá  , :n , :y ))
# Gas constant / System constant anomalous
mkBasAmt(:RAmt , :BProperty, :R , "mR", u"kJ/K", "kJ/K", "gas constant"       , false, bsym=(:mR , :mÃáR , :R , :RÃÑ ))
# Pv product anomalous
mkBasAmt(:PvAmt, :BProperty, :Pv, "PV", u"kJ"  , "kJ"  , "flux work"          , false, bsym=(:PV , :PVÃá , :Pv, :PvÃÑ))
# RT product anomalous
mkBasAmt(:RTAmt, :BProperty, :RT, "RT", u"kJ"  , "kJ"  , "RT product"         , false, bsym=(:mRT, :mÃáRT, :RT, :RÃÑT))
# Ts product anomalous
mkBasAmt(:TsAmt, :BProperty, :Ts, "Ts", u"kJ"  , "kJ"  , "Ts product"         , false, bsym=(:TS , :TSÃá , :Ts, :TsÃÑ))

# Regular properties
mkBasAmt(:vAmt , :BProperty, :v , "V" , u"m^3" , "m¬≥"  , "volume"             , false)
mkBasAmt(:uAmt , :BProperty, :u , "U" , u"kJ"  , "kJ"  , "internal energy"    , false)
mkBasAmt(:hAmt , :BProperty, :h , "H" , u"kJ"  , "kJ"  , "enthalpy"           , false)
mkBasAmt(:gAmt , :BProperty, :g , "G" , u"kJ"  , "kJ"  , "Gibbs energy"       , false)
mkBasAmt(:aAmt , :BProperty, :a , "A" , u"kJ"  , "kJ"  , "Helmholtz energy"   , false)
mkBasAmt(:eAmt , :BProperty, :e , "E" , u"kJ"  , "kJ"  , "total energy"       , false)
mkBasAmt(:ekAmt, :BProperty, :ek, "Ek", u"kJ"  , "kJ"  , "kinetic energy"     , false)
mkBasAmt(:epAmt, :BProperty, :ep, "Ep", u"kJ"  , "kJ"  , "potential energy"   , false)
mkBasAmt(:sAmt , :BProperty, :s , "S" , u"kJ/K", "kJ/K", "entropy"            , false)
mkBasAmt(:cpAmt, :BProperty, :cp, "Cp", u"kJ/K", "kJ/K", "iso-P specific heat", false)
mkBasAmt(:cvAmt, :BProperty, :cv, "Cv", u"kJ/K", "kJ/K", "iso-v specific heat", false)
mkBasAmt(:cAmt , :BProperty, :c , "C" , u"kJ/K", "kJ/K", "incompressible substance specific heat", false)
mkBasAmt(:jAmt , :BProperty, :j , "J" , u"kJ/K", "kJ/K", "Massieu function"   , false)
mkBasAmt(:yAmt , :BProperty, :y , "Y" , u"kJ/K", "kJ/K", "Planck function"    , false)

# Regular interactions
mkBasAmt(:qAmt , :BInteract, :q , "Q" , u"kJ"  , "kJ"  , "heat"               , false)
mkBasAmt(:wAmt , :BInteract, :w , "W" , u"kJ"  , "kJ"  , "work"               , false)
mkBasAmt(:ŒîeAmt, :BInteract, :Œîe, "E" , u"kJ"  , "kJ"  , "energy variation"   , true )
mkBasAmt(:ŒîsAmt, :BInteract, :Œîs, "S" , u"kJ/K", "kJ/K", "entropy variation"  , true )


#----------------------------------------------------------------------------------------------#
#                                      AMOUNT Type Unions                                      #
#----------------------------------------------------------------------------------------------#

# Unions of amounts of like units and thermodynamic classification, for same-unit operations

# --- energy
"""
`ENERGYP{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Energy property type union.
"""
ENERGYP{ùóΩ,ùòÖ,ùóØ} = Union{uAmt{ùóΩ,ùòÖ,ùóØ},hAmt{ùóΩ,ùòÖ,ùóØ},
                       gAmt{ùóΩ,ùòÖ,ùóØ},aAmt{ùóΩ,ùòÖ,ùóØ},
                       eAmt{ùóΩ,ùòÖ,ùóØ},ekAmt{ùóΩ,ùòÖ,ùóØ},
                       epAmt{ùóΩ,ùòÖ,ùóØ},PvAmt{ùóΩ,ùòÖ,ùóØ},
                       RTAmt{ùóΩ,ùòÖ,ùóØ},TsAmt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`ENERGYI{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Energy interaction type union.
"""
ENERGYI{ùóΩ,ùòÖ,ùóØ} = Union{qAmt{ùóΩ,ùòÖ,ùóØ},wAmt{ùóΩ,ùòÖ,ùóØ},
                       ŒîeAmt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`ENERGYA{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Energy amount type union.
"""
ENERGYA{ùóΩ,ùòÖ,ùóØ} = Union{ENERGYP{ùóΩ,ùòÖ,ùóØ},ENERGYI{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}


# --- entropy
"""
`NTROPYP{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Entropy property type union.
"""
NTROPYP{ùóΩ,ùòÖ,ùóØ} = Union{RAmt{ùóΩ,ùòÖ,ùóØ},yAmt{ùóΩ,ùòÖ,ùóØ},sAmt{ùóΩ,ùòÖ,ùóØ},
                       jAmt{ùóΩ,ùòÖ,ùóØ},cAmt{ùóΩ,ùòÖ,ùóØ},
                       cpAmt{ùóΩ,ùòÖ,ùóØ},cvAmt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`NTROPYI{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Entropy interaction type union.
"""
NTROPYI{ùóΩ,ùòÖ,ùóØ} = Union{ŒîsAmt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`NTROPYA{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Entropy amount type union.
"""
NTROPYA{ùóΩ,ùòÖ,ùóØ} = Union{NTROPYP{ùóΩ,ùòÖ,ùóØ},NTROPYI{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}


# --- velocity
"""
`VELOCYP{ùóΩ,ùòÖ} where {ùóΩ<:PREC,ùòÖ<:EXAC}`\n
Velocity property type union.
"""
VELOCYP{ùóΩ,ùòÖ} = Union{VELO{ùóΩ,ùòÖ},SPEE{ùóΩ,ùòÖ},ùïîAmt{ùóΩ,ùòÖ}} where {ùóΩ<:PREC,ùòÖ<:EXAC}


# --- dimensionless
"""
`DIMLESS{ùóΩ,ùòÖ} where {ùóΩ<:PREC,ùòÖ<:EXAC}`\n
Dimensionless amount type union.
"""
DIMLESS{ùóΩ,ùòÖ} = Union{√∏Amt{ùóΩ,ùòÖ},ZAmt{ùóΩ,ùòÖ},Œ≥Amt{ùóΩ,ùòÖ},kAmt{ùóΩ,ùòÖ},
                     MaAmt{ùóΩ,ùòÖ},PrAmt{ùóΩ,ùòÖ},vrAmt{ùóΩ,ùòÖ}} where {ùóΩ<:PREC,ùòÖ<:EXAC}


#----------------------------------------------------------------------------------------------#
#                                       Pretty Printing                                        #
#----------------------------------------------------------------------------------------------#

import Base: show

# Auxiliary methods
function subscript(x::Int)
    asSub(c::Char) = Char(Int(c) - Int('0') + Int('‚ÇÄ'))
    map(asSub, "$(x)")
end

function valFmt(x::ùóΩ, sigD = DEF[:showSigD]) where ùóΩ<:PREC
    y = Float64(x)
    buffr = repeat([0x0, ], 1024+14)
    bytes = ccall(
        :sprintf, Int32, (Ptr{UInt8}, Cstring, Int64, Float64),
        buffr, "%#.*g", sigD, y)
    return bytes < length(buffr) ? unsafe_string(pointer(buffr)) : "#VALUE!"
end

# Precision decoration
pDeco(::Type{Float16})  = DEF[:showPrec] ? subscript(16) : ""
pDeco(::Type{Float32})  = DEF[:showPrec] ? subscript(32) : ""
pDeco(::Type{Float64})  = DEF[:showPrec] ? subscript(64) : ""
pDeco(::Type{BigFloat}) = DEF[:showPrec] ? subscript(precision(BigFloat)) : ""

# Custom printing
Base.show(io::IO, x::AMOUNTS{ùóΩ,EX}) where ùóΩ<:PREC = begin
    if DEF[:pprint]
        print(io,
            "$(string(deco(x)))$(pDeco(ùóΩ)): ",
            valFmt(amt(x).val),
            ppu(x) == "" ? "" : " $(ppu(x))"
        )
    else
        print(io,
            "$(typeof(x))(",
            valFmt(amt(x).val),
            ppu(x) == "" ? ")" : " $(ppu(x)))"
        )
    end
end

Base.show(io::IO, x::AMOUNTS{ùóΩ,MM}) where ùóΩ<:PREC = begin
    if DEF[:pprint]
        print(io,
            "$(string(deco(x)))$(pDeco(ùóΩ)): (",
            valFmt(amt(x).val.val),
            " ¬± ",
            valFmt(amt(x).val.err, 2),
            ppu(x) == "" ? "" : " $(ppu(x)))"
        )
    else
        print(io,
            "$(typeof(x))(",
            valFmt(amt(x).val.val),
            " ¬± ",
            valFmt(amt(x).val.err, 2),
            ppu(x) == "" ? ")" : " $(ppu(x)))"
        )
    end
end


#      TYPE  FUNC    SY         L5TYP  FINT    SY
#     ------------------        ------------------
#      _Amt    _a     _         __amt    _a     _
#      sysT     T     T         T_amt    T_     T
#      sysP     P     P         P_amt    P_     P
#      VELO  velo     ùïç         veamt    ve     ùïç
#      SPEE  spee     ùïß         spamt    sp     ùïß
#      TIME     t     t         t_amt    t_     t
#      GRAV  grav     ùíà         gvamt    gv     ùíà
#      zAmt     z     z         z_amt    z_     z
#      ZAmt     Z     Z         Z_amt    Z_     Z
#      Œ≥Amt     Œ≥     Œ≥         gaamt    ga     Œ≥
#      Œ≤Amt     Œ≤     Œ≤         beamt    be     Œ≤
#     Œ∫TAmt    Œ∫T    Œ∫T         kTamt    kT    Œ∫T
#     Œ∫sAmt    Œ∫s    Œ∫s         ksamt    ks    Œ∫s
#      kAmt     k     k         k_amt    k_     k
#      ùïîAmt     ùïî     ùïî         csamt    cs    cs
#     MaAmt    Ma    Ma         Maamt    Ma    Ma
#     ŒºJAmt   ŒºJT   ŒºJT         mJamt    mJ    ŒºJ
#     ŒºSAmt    ŒºS    ŒºS         mSamt    mS    ŒºS
#      xAmt     x     x         x_amt    x_     x
#     PrAmt    Pr    Pr         Pramt    Pr    Pr
#     vrAmt    vr    vr         vramt    vr    vr
#      √∏Amt     √∏     √∏         √∏_amt    √∏_     √∏
#      mAmt     m    **         m_amt    m_    **
#      nAmt     N    **         N_amt    N_    **
#      RAmt     R    **         R_amt    R_    **
#     PvAmt    Pv    **         Pvamt    Pv    **
#     RTAmt    RT    **         RTamt    RT    **
#     TsAmt    Ts    **         Tsamt    Ts    **
#      vAmt     v     v         v_amt    v_     v
#      uAmt     u     u         u_amt    u_     u
#      hAmt     h     h         h_amt    h_     h
#      gAmt     g     g         g_amt    g_     g
#      aAmt     a     a         a_amt    a_     a
#      eAmt     e     e         e_amt    e_     e
#     ekAmt    ek    ek         ekamt    ek    ek
#     epAmt    ep    ep         epamt    ep    ep
#      sAmt     s     s         s_amt    s_     s
#     cpAmt    cp    cp         cpamt    cp    cp
#     cvAmt    cv    cv         cvamt    cv    cv
#      cAmt     c     c         c_amt    c_     c
#      jAmt     j     j         j_amt    j_     j
#      yAmt     y     y         y_amt    y_     y
#      qAmt     q     q         q_amt    q_     q
#      wAmt     w     w         w_amt    w_     w
#     ŒîeAmt    Œîe    Œîe         deamt    de    Œîe
#     ŒîsAmt    Œîs    Œîs         dsamt    ds    Œîs

