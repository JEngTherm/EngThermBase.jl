#----------------------------------------------------------------------------------------------#
#                                    Amount Type Interface                                     #
#----------------------------------------------------------------------------------------------#

"""
`function deco end`\n
Interface to return a unique decorative `Symbol` from a method's argument type.
"""
function deco end

"""
`function ppu end`\n
Interface to pretty-print units.
"""
function ppu end

# An original 191113-212130 benchmark showed amt(x) is      faster than x.amt:
# An  updated 220927-010045 benchmark showed amt(x) is stil faster than x.amt:
#
# ```julia-repl
# julia> u1 = u_(1.0f0 ¬± 0.1f0, MO)
# ≈´‚ÇÉ‚ÇÇ: (1.0000 ¬± 0.10 kJ/kmol)
#
# julia> typeof(u1)
# u_amt{Float32, MM, MO}
#
# julia> @benchmark u1.amt
# ‚úÇ ‚úÇ ‚úÇ   median time:      29.054 ns   ‚úÇ ‚úÇ ‚úÇ
#
# julia> @benchmark amt(u1)
# ‚úÇ ‚úÇ ‚úÇ   median time:      16.784 ns   ‚úÇ ‚úÇ ‚úÇ
#
# ```

"""
`function amt end`\n
Interface to get an `AMOUNTS`' `:amt` field in a type-stable manner.
"""
function amt end

export deco, ppu, amt


#----------------------------------------------------------------------------------------------#
#                                     Generic Amount Type                                      #
#----------------------------------------------------------------------------------------------#

import Base: cp, convert
import Unicode: normalize
import Base: +, -, *, /

"""
Generic Amount type factory.
"""
function mkGenAmt(TYPE::Symbol,         # Type name:            :__amt
                  SUPT::Symbol,         # Supertype:            :GenerAmt
                  FNAM::Symbol,         # Function Name:        :_a
                  ALIA::Symbol,         # Function Alias:       :ùóî
                  SYMB::AbstractString, # Printing symbol:      "_"
                  WHAT::AbstractString, # Description:          "generic amounts"
                  DELT::Bool=false,     # Whether a Œî quantity
                 )
    # Constants
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = normalize((DELT ? "Œî" : "") * string(SYMB))
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC} <: $SUPT{ùóΩ,ùòÖ}`\n
Precision-, and Exactness- parametric $WHAT amounts based in arbitrary units.\n
`$TYPE{ùóΩ,ùòÖ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with any units.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    fnStr = "Function to return $WHAT amounts of arbitrary units."
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ} <: $SUPT{ùóΩ,ùòÖ}
            amt::UATY{ùóΩ} where ùóΩ<:PREC
            # Inner, non-converting, parameter-determining constructors
            $TYPE(x::$TYPE{ùóΩ,ùòÖ}) where {ùóΩ<:PREC,ùòÖ<:EXAC} = new{ùóΩ,ùòÖ}(amt(x))
            $TYPE(x::Union{ùóΩ,UETY{ùóΩ}}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x))
            $TYPE(x::Union{PMTY{ùóΩ},UMTY{ùóΩ}}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x))
            # Inner, non-converting, fully-specified constructors
            (::Type{$TYPE{ùóΩ,EX}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x))
            (::Type{$TYPE{ùóΩ,EX}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x.val))
            (::Type{$TYPE{ùóΩ,MM}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(measurement(x)))
            (::Type{$TYPE{ùóΩ,MM}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x))
        end
        # Type documentation
        @doc $dcStr $TYPE
        # External constructors for other DataTypes:
        $TYPE(x::REAL) = $TYPE(float(x))
        $TYPE(x::uniR{ùóΩ}) where ùóΩ<:REAL = $TYPE(float(x.val) * unit(x))
        $TYPE(x::AMOUNTS) = $TYPE(amt(x)) # AMOUNTS fallback
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(ùòÄ(amt(x).val) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val) * unit(amt(x)))
        end
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(ùòÄ(amt(x).val) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(ùòÄ(amt(x).val.val) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX},
                              e::ùòÄ=ùòÄ(max(eps(ùòÄ), eps(amt(x).val)))) where {ùòÄ<:PREC,
                                                                           ùóΩ<:PREC} = begin
            $TYPE(measurement(ùòÄ(amt(x).val), e) * unit(amt(x)))
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM}) where {ùòÄ<:PREC,ùóΩ<:PREC} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val) * unit(amt(x)))
        end
        # Type export
        export $TYPE
        # Type-stabler wrapped amount obtaining function
        amt(x::$TYPE{ùóΩ,EX}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ}
        amt(x::$TYPE{ùóΩ,MM}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ}}
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        ppu(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = string(unit(amt(x)))
        # Function interface
        function $FNAM end
        @doc $fnStr $FNAM
        # Indirect construction from Numb
        $FNAM(x::Union{Numb,AMOUNTS}) = $TYPE(x)
        # Function aliasing and export
        $ALIA = $FNAM
        export $FNAM, $ALIA
        # Conversions
        convert(::Type{$TYPE{ùòÄ,ùòÖ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        convert(::Type{$TYPE{ùòÄ,ùòÜ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}
        end
        # same-type sum,sub with Unitful promotion
        +(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(+(amt(x), amt(y)))
        end
        -(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(-(amt(x), amt(y)))
        end
        # scalar mul,div with Unitful promotion
        *(y::plnF{ùòÄ}, x::$TYPE{ùóΩ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        *(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        /(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(/(amt(x), y))
        # Type-preserving scalar mul,div
        *(y::REAL, x::$TYPE{ùóΩ}) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        *(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        /(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(/(amt(x), ùóΩ(y)))
    end
end

#----------------------------------------------------------------------------------------------#
#                                 Generic Amount Declarations                                  #
#----------------------------------------------------------------------------------------------#

# The fallback generic amount
mkGenAmt(:__amt, :GenerAmt, :_a, :ùóî, "_", "generic", false)


#----------------------------------------------------------------------------------------------#
#                                  Whole Amount Type Factory                                   #
#----------------------------------------------------------------------------------------------#

"""
Whole Amount type factory.
"""
function mkWhlAmt(TYPE::Symbol,         # Type name:            :T_amt
                  SUPT::Symbol,         # Supertype:            :WProperty
                  FNAM::Symbol,         # Function Name:        :T_
                  ALIA::Symbol,         # Function Alias:       :ùóß
                  SYMB::AbstractString, # Printing symbol:      "T"
                  UNIT::Unitful.Units,  # SY quantity units:    u"K"
                  USTR::AbstractString, # PrettyPrinting units: "K"
                  WHAT::AbstractString, # Description:          "temperature"
                  DELT::Bool=false,     # Whether a Œî quantity
                 )
    # Constants
    uSY = UNIT
    ùë¢SY = typeof(uSY)
    ùëëSY = dimension(uSY)
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = normalize((DELT ? "Œî" : "") * string(SYMB))
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC} <: $SUPT{ùóΩ,ùòÖ}`\n
Precision-, and Exactness- parametric $WHAT amounts based in $USTR.\n
`$TYPE{ùóΩ,ùòÖ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with compatible units.\n
Constructors determine all parameters from their arguments.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    fnStr = "Function to return $WHAT amounts in ($USTR)."
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ} <: $SUPT{ùóΩ,ùòÖ}
            amt::UATY{ùóΩ,$ùëëSY,$ùë¢SY} where ùóΩ<:PREC
            # Inner, non-converting, parameter-determining constructors
            # ---------------------------------------------------------
            # Copy constructor
            $TYPE(x::$TYPE{ùóΩ,ùòÖ}) where {ùóΩ<:PREC,ùòÖ<:EXAC} = new{ùóΩ,ùòÖ}(amt(x))
            # Plain constructors enforce default units & avoid unit conversion
            $TYPE(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x * $uSY))
            $TYPE(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x * $uSY))
            # Quantity constructors have to perform unit conversion despite matching dimensions
            $TYPE(x::UETY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(uconvert($uSY, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(uconvert($uSY, x)))
            # Inner, non-converting, fully-specified constructors
            # ---------------------------------------------------
            (::Type{$TYPE{ùóΩ,EX}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x * $uSY))
            (::Type{$TYPE{ùóΩ,EX}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,EX}(_qty(x.val * $uSY))
            (::Type{$TYPE{ùóΩ,MM}})(x::ùóΩ) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(measurement(x) * $uSY))
            (::Type{$TYPE{ùóΩ,MM}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = new{ùóΩ,MM}(_qty(x * $uSY))
        end
        # Type documentation
        @doc $dcStr $TYPE
        # External constructors for other DataTypes:
        $TYPE(x::REAL) = $TYPE(float(x))
        $TYPE(x::uniR{ùóΩ,$ùëëSY}) where ùóΩ<:REAL = $TYPE(float(x.val) * unit(x))
        $TYPE(x::AMOUNTS) = $TYPE(amt(x)) # AMOUNTS fallback
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX}
                          ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(amt(x).val))
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM}
                          ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(Measurement{ùòÄ}(amt(x).val))
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(amt(x).val))
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(ùòÄ(amt(x).val.val))
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX},
                              e::ùòÄ=ùòÄ(max(eps(ùòÄ),eps(amt(x).val)))
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(measurement(ùòÄ(amt(x).val), e))
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM}
                             ) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(Measurement{ùòÄ}(amt(x).val))
        # Type export
        export $TYPE
        # Type-stable wrapped amount obtaining function
        amt(x::$TYPE{ùóΩ,EX}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëSY,$ùë¢SY}
        amt(x::$TYPE{ùóΩ,MM}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëSY,$ùë¢SY}
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        ppu(x::$TYPE{ùóΩ,ùòÖ} where {ùóΩ,ùòÖ}) = $USTR
        # Function interface
        function $FNAM end
        @doc $fnStr $FNAM
        # Indirect construction from Numb
        $FNAM(x::Union{Numb,AMOUNTS}) = $TYPE(x)
        # Function aliasing and export
        $ALIA = $FNAM
        export $FNAM, $ALIA
        # Conversions
        convert(::Type{$TYPE{ùòÄ,ùòÖ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        convert(::Type{$TYPE{ùòÄ,ùòÜ}},
                y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}
        end
        # same-type sum,sub with Unitful promotion
        +(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(+(amt(x), amt(y)))
        end
        -(x::$TYPE{ùòÄ,ùòÜ}, y::$TYPE{ùóΩ,ùòÖ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC} = begin
            $TYPE(-(amt(x), amt(y)))
        end
        # scalar mul,div with Unitful promotion
        *(y::plnF{ùòÄ}, x::$TYPE{ùóΩ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        *(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        /(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(/(amt(x), y))
        # Type-preserving scalar mul,div
        *(y::REAL, x::$TYPE{ùóΩ}) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        *(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        /(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(/(amt(x), ùóΩ(y)))
    end
end


#----------------------------------------------------------------------------------------------#
#                           Thermodynamic Whole Amount Declarations                            #
#----------------------------------------------------------------------------------------------#

# Regular properties -- \bb#<TAB> velocity/speed function names
mkWhlAmt(:T_amt, :WProperty, :T_, :ùóß , "T" , u"K"       , "K"       , "temperature", false)
mkWhlAmt(:P_amt, :WProperty, :P_, :ùó£ , "P" , u"kPa"     , "kPa"     , "pressure"   , false)
mkWhlAmt(:veamt, :WProperty, :ve, :ùïç , "ùïç" , u"‚àö(kJ/kg)", "‚àö(kJ/kg)", "velocity"   , false)
mkWhlAmt(:spamt, :WProperty, :sp, :ùïß , "ùïß" , u"m/s"     , "m/s"     , "speed"      , false)

# Regular unranked -- \sans#<TAB> function names
mkWhlAmt(:t_amt, :WUnranked, :t_, :ùòÅ , "ùóç" , u"s"       , "s"       , "time"       , false)
mkWhlAmt(:gvamt, :WUnranked, :gv, :ùíà , "ùíà" , u"m/s^2"   , "m/s¬≤"    , "gravity"    , false)
mkWhlAmt(:z_amt, :WUnranked, :z_, :ùòá , "ùóì" , u"m"       , "m"       , "altitude"   , false)

# Derived thermodynamic properties
mkWhlAmt(:Z_amt, :WProperty, :Z_, :ùó≠ , "Z" , ULESS()    , "‚Äì"       , "generalized compressibility factor", false)
mkWhlAmt(:gaamt, :WProperty, :ga, :ùù≤ , "Œ≥" , ULESS()    , "‚Äì"       , "specific heat ratio"               , false)
mkWhlAmt(:beamt, :WProperty, :be, :ùù± , "Œ≤" , inv(u"K")  , "/K"      , "coefficient of volume expansion"   , false)
mkWhlAmt(:kTamt, :WProperty, :kT, :ùùπùóß, "Œ∫T", inv(u"kPa"), "/kPa"    , "isothermal compressibility"        , false)
mkWhlAmt(:ksamt, :WProperty, :ks, :ùùπùòÄ, "Œ∫s", inv(u"kPa"), "/kPa"    , "isentropic compressibility"        , false)
mkWhlAmt(:k_amt, :WProperty, :k_, :ùó∏ , "k" , ULESS()    , "‚Äì"       , "isentropic expansion exponent"     , false)
mkWhlAmt(:csamt, :WProperty, :cs, :ùó∞ùòÄ, "ùïî" , u"‚àö(kJ/kg)", "‚àö(kJ/kg)", "adiabatic speed of sound"          , false)
mkWhlAmt(:Maamt, :WProperty, :Ma, :ùó†ùóÆ, "Ma", ULESS()    , "‚Äì"       , "Mach number"                       , false)
mkWhlAmt(:mJamt, :WProperty, :mJ, :ùùªùóù, "ŒºJ", u"K/kPa"   , "K/kPa"   , "Joule-Thomson coefficient"         , false)
mkWhlAmt(:mSamt, :WProperty, :mS, :ùùªùó¶, "ŒºS", u"K/kPa"   , "K/kPa"   , "isentropic expansion coefficient"  , false)
mkWhlAmt(:x_amt, :WProperty, :x_, :ùòÖ , "x" , ULESS()    , "‚Äì"       , "saturated vapor mass fraction"     , false)
mkWhlAmt(:Pramt, :WProperty, :Pr, :ùó£ùóø, "Pr", ULESS()    , "‚Äì"       , "relative pressure"                 , false)
mkWhlAmt(:vramt, :WProperty, :vr, :ùòÉùóø, "vr", ULESS()    , "‚Äì"       , "relative specific volume"          , false)

# Generic dimensionless ratio
mkWhlAmt(:√∏_amt, :WUnranked, :√∏_, :√∏ , "√∏" , ULESS()    , "‚Äì"       , "generic dimensionless ratio"       , false)


#----------------------------------------------------------------------------------------------#
#                                  Based Amount Type Factory                                   #
#----------------------------------------------------------------------------------------------#

"""
Based Amount type factory.
"""
function mkBasAmt(TYPE::Symbol,         # Type Name:            :u_Amt
                  SUPT::Symbol,         # Supertype:            :BProperty
                  FNAM::Symbol,         # Function Name:        :u_
                  ALIA::Symbol,         # Function Alias:       :ùòÇ
                  SYMB::AbstractString, # Printing symbol:      "U"
                  UNIT::Unitful.Units,  # SY quantity units:    u"kJ"
                  USTR::AbstractString, # PrettyPrinting units: "K"
                  WHAT::AbstractString, # Description:          "internal energy"
                  DELT::Bool=false;     # Whether a Œî quantity
                  bsym::NTuple{4,Symbol}=(:none,:none,:none,:none)
                 )
    # Constants
    uSY = UNIT
    uDT = UNIT / u"s"
    uMA = UNIT / u"kg"
    uMO = UNIT / u"kmol"
    ùë¢SY = typeof(uSY)
    ùë¢DT = typeof(uDT)
    ùë¢MA = typeof(uMA)
    ùë¢MO = typeof(uMO)
    ùëëSY = dimension(uSY)
    ùëëDT = dimension(uDT)
    ùëëMA = dimension(uMA)
    ùëëMO = dimension(uMO)
    i, f = DELT ? (3, 4) : (1, 2)
    ùë†SY = bsym[1] == :none ?
        normalize((DELT ? "Œî" : "") * uppercase(string(SYMB))) :
        string(bsym[1])
    ùë†DT = bsym[2] == :none ?
        normalize(string(ùë†SY[1:i], "\u0307", ùë†SY[f:end])) :
        string(bsym[2])
    ùë†MA = bsym[3] == :none ?
        normalize((DELT ? "Œî" : "") * lowercase(string(SYMB))) :
        string(bsym[3])
    ùë†MO = bsym[4] == :none ?
        normalize(string(ùë†MA[1:i], "\u0304", ùë†MA[f:end])) :
        string(bsym[4])
    # Documentation
    hiStr = tyArchy(eval(SUPT))
    dcStr = """
`struct $TYPE{ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} <: $SUPT{ùóΩ,ùòÖ,ùóØ}`\n
Precision-, Exactness-, and Base- parametric $WHAT amounts based in $USTR.\n
`$TYPE{ùóΩ,ùòÖ,ùóØ}` parameters are:\n
- Precision `ùóΩ<:Union{Float16,Float32,Float64,BigFloat}`;\n
- Exactness `ùòÖ<:Union{EX,MM}`, i.e., either a single, precise value or an uncertainty-bearing
  measurement, respectively;\n
- Thermodynamic base `ùóØ<:Union{SY,DT,MA,MO}` respectively for system, rate, mass, or molar
  quantities, respectively in units of $(uSY), $(uDT), $(uMA), or $(uMO).\n
A `$TYPE` can be natively constructed from the following argument types:\n
- A plain, unitless float;\n
- A plain, unitless `Measurement`; hence, any `AbstractFloat`;\n
- A `Quantity{AbstractFloat}` with compatible units.\n
Constructors determine parameters from their arguments. `Quantity` constructors do not need a
base argument. Plain, `AbstractFloat` ones require the base argument.\n
## Hierarchy\n
`$(TYPE) <: $(hiStr)`
    """
    fnStr = "Function to return $WHAT amounts in ($USTR)."
    # @eval block
    @eval begin
        # Concrete type definition
        struct $TYPE{ùóΩ,ùòÖ,ùóØ} <: $SUPT{ùóΩ,ùòÖ,ùóØ}
            amt::Union{UATY{ùóΩ,$ùëëSY,$ùë¢SY},UATY{ùóΩ,$ùëëDT,$ùë¢DT},
                       UATY{ùóΩ,$ùëëMA,$ùë¢MA},UATY{ùóΩ,$ùëëMO,$ùë¢MO}} where ùóΩ<:PREC
            # Inner, non-converting, parameter-determining constructors
            # ---------------------------------------------------------
            # Copy constructor
            $TYPE(x::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} = new{ùóΩ,ùòÖ,ùóØ}(amt(x))
            # Plain constructors enforce default units & avoid unit conversion
            # Plain Exact (ùóΩ<:PREC) float constructors
            $TYPE(x::ùóΩ, ::Type{SY}) where ùóΩ<:PREC = new{ùóΩ,EX,SY}(_qty(x * $uSY))
            $TYPE(x::ùóΩ, ::Type{DT}) where ùóΩ<:PREC = new{ùóΩ,EX,DT}(_qty(x * $uDT))
            $TYPE(x::ùóΩ, ::Type{MA}) where ùóΩ<:PREC = new{ùóΩ,EX,MA}(_qty(x * $uMA))
            $TYPE(x::ùóΩ, ::Type{MO}) where ùóΩ<:PREC = new{ùóΩ,EX,MO}(_qty(x * $uMO))
            # Plain Measurement (PMTY) constructors
            $TYPE(x::PMTY{ùóΩ}, ::Type{SY}) where ùóΩ<:PREC = new{ùóΩ,MM,SY}(_qty(x * $uSY))
            $TYPE(x::PMTY{ùóΩ}, ::Type{DT}) where ùóΩ<:PREC = new{ùóΩ,MM,DT}(_qty(x * $uDT))
            $TYPE(x::PMTY{ùóΩ}, ::Type{MA}) where ùóΩ<:PREC = new{ùóΩ,MM,MA}(_qty(x * $uMA))
            $TYPE(x::PMTY{ùóΩ}, ::Type{MO}) where ùóΩ<:PREC = new{ùóΩ,MM,MO}(_qty(x * $uMO))
            # Quantity constructors have to perform unit conversion despite matching dimensions
            # United Exact (UETY) constructors
            $TYPE(x::UETY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,EX,SY}(_qty(uconvert($uSY, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëDT}) where ùóΩ<:PREC = new{ùóΩ,EX,DT}(_qty(uconvert($uDT, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëMA}) where ùóΩ<:PREC = new{ùóΩ,EX,MA}(_qty(uconvert($uMA, x)))
            $TYPE(x::UETY{ùóΩ,$ùëëMO}) where ùóΩ<:PREC = new{ùóΩ,EX,MO}(_qty(uconvert($uMO, x)))
            # United Measurement (UMTY) constructors
            $TYPE(x::UMTY{ùóΩ,$ùëëSY}) where ùóΩ<:PREC = new{ùóΩ,MM,SY}(_qty(uconvert($uSY, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëDT}) where ùóΩ<:PREC = new{ùóΩ,MM,DT}(_qty(uconvert($uDT, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëMA}) where ùóΩ<:PREC = new{ùóΩ,MM,MA}(_qty(uconvert($uMA, x)))
            $TYPE(x::UMTY{ùóΩ,$ùëëMO}) where ùóΩ<:PREC = new{ùóΩ,MM,MO}(_qty(uconvert($uMO, x)))
            # Inner, non-converting, fully-specified constructors
            # ---------------------------------------------------
            # SY-based constructors
            (::Type{$TYPE{ùóΩ,EX,SY}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,SY}(_qty(             x * $uSY))
            end
            (::Type{$TYPE{ùóΩ,EX,SY}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,SY}(_qty(         x.val * $uSY))
            end
            (::Type{$TYPE{ùóΩ,MM,SY}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,SY}(_qty(measurement(x) * $uSY))
            end
            (::Type{$TYPE{ùóΩ,MM,SY}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,SY}(_qty(             x * $uSY))
            end
            # DT-based constructors
            (::Type{$TYPE{ùóΩ,EX,DT}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,DT}(_qty(             x * $uDT))
            end
            (::Type{$TYPE{ùóΩ,EX,DT}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,DT}(_qty(         x.val * $uDT))
            end
            (::Type{$TYPE{ùóΩ,MM,DT}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,DT}(_qty(measurement(x) * $uDT))
            end
            (::Type{$TYPE{ùóΩ,MM,DT}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,DT}(_qty(             x * $uDT))
            end
            # MA-based constructors
            (::Type{$TYPE{ùóΩ,EX,MA}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MA}(_qty(             x * $uMA))
            end
            (::Type{$TYPE{ùóΩ,EX,MA}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MA}(_qty(         x.val * $uMA))
            end
            (::Type{$TYPE{ùóΩ,MM,MA}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MA}(_qty(measurement(x) * $uMA))
            end
            (::Type{$TYPE{ùóΩ,MM,MA}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MA}(_qty(             x * $uMA))
            end
            # MO-based constructors
            (::Type{$TYPE{ùóΩ,EX,MO}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MO}(_qty(             x * $uMO))
            end
            (::Type{$TYPE{ùóΩ,EX,MO}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,EX,MO}(_qty(         x.val * $uMO))
            end
            (::Type{$TYPE{ùóΩ,MM,MO}})(x::ùóΩ) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MO}(_qty(measurement(x) * $uMO))
            end
            (::Type{$TYPE{ùóΩ,MM,MO}})(x::PMTY{ùóΩ}) where ùóΩ<:PREC = begin
                new{ùóΩ,MM,MO}(_qty(             x * $uMO))
            end
        end
        # Type documentation
        @doc $dcStr $TYPE
        # External constructors for other DataTypes:
        $TYPE(x::plnF) = $TYPE(x, DEF[:IB])
        $TYPE(x::REAL, b::Type{ùóØ}=DEF[:IB]) where ùóØ<:BASE = $TYPE(float(x), b)
        $TYPE(x::Union{uniR{ùóΩ,$ùëëSY},uniR{ùóΩ,$ùëëDT},
                       uniR{ùóΩ,$ùëëMA},uniR{ùóΩ,$ùëëMO}}) where ùóΩ<:REAL = begin
            $TYPE(float(x.val) * unit(x))
        end
        $TYPE(x::AMOUNTS) = $TYPE(amt(x)) # AMOUNTS fallback
        # Precision-changing external constructors
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,EX,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(amt(x).val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val), ùóØ)
        end
        # Precision+Exactness-changing external constructors
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,EX,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(amt(x).val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,EX}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(ùòÄ(amt(x).val.val), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,EX,ùóØ},
                            e::ùòÄ=ùòÄ(max(eps(ùòÄ),eps(amt(x).val)))
                            ) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(measurement(ùòÄ(amt(x).val), e), ùóØ)
        end
        (::Type{$TYPE{ùòÄ,MM}})(x::$TYPE{ùóΩ,MM,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùóØ<:BASE} = begin
            $TYPE(Measurement{ùòÄ}(amt(x).val), ùóØ)
        end
        # Type export
        export $TYPE
        # Type-stable wrapped amount obtaining function
        amt(x::$TYPE{ùóΩ,EX,SY}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëSY,$ùë¢SY}
        amt(x::$TYPE{ùóΩ,EX,DT}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëDT,$ùë¢DT}
        amt(x::$TYPE{ùóΩ,EX,MA}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëMA,$ùë¢MA}
        amt(x::$TYPE{ùóΩ,EX,MO}) where ùóΩ<:PREC = x.amt::Quantity{ùóΩ,$ùëëMO,$ùë¢MO}
        amt(x::$TYPE{ùóΩ,MM,SY}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëSY,$ùë¢SY}
        amt(x::$TYPE{ùóΩ,MM,DT}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëDT,$ùë¢DT}
        amt(x::$TYPE{ùóΩ,MM,MA}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëMA,$ùë¢MA}
        amt(x::$TYPE{ùóΩ,MM,MO}) where ùóΩ<:PREC = x.amt::Quantity{Measurement{ùóΩ},$ùëëMO,$ùë¢MO}
        # Type-specific functions
        deco(x::$TYPE{ùóΩ,ùòÖ,SY} where {ùóΩ,ùòÖ}) = Symbol($ùë†SY)
        deco(x::$TYPE{ùóΩ,ùòÖ,DT} where {ùóΩ,ùòÖ}) = Symbol($ùë†DT)
        deco(x::$TYPE{ùóΩ,ùòÖ,MA} where {ùóΩ,ùòÖ}) = Symbol($ùë†MA)
        deco(x::$TYPE{ùóΩ,ùòÖ,MO} where {ùóΩ,ùòÖ}) = Symbol($ùë†MO)
        ppu(x::$TYPE{ùóΩ,ùòÖ,SY} where {ùóΩ,ùòÖ}) = $USTR
        ppu(x::$TYPE{ùóΩ,ùòÖ,DT} where {ùóΩ,ùòÖ}) = $USTR * "/s"
        ppu(x::$TYPE{ùóΩ,ùòÖ,MA} where {ùóΩ,ùòÖ}) = $USTR * "/kg"
        ppu(x::$TYPE{ùóΩ,ùòÖ,MO} where {ùóΩ,ùòÖ}) = $USTR * "/kmol"
        # Function interface
        function $FNAM end
        @doc $fnStr $FNAM
        # Indirect construction from Numb
        $FNAM(x::Union{Numb,AMOUNTS}) = $TYPE(x)
        $FNAM(x::Numb, ::Type{ùóØ}) where ùóØ<:BASE = $TYPE(x, ùóØ)
        # Function aliasing and export
        $ALIA = $FNAM
        export $FNAM, $ALIA
        # Conversions - Change of base is _not_ a conversion
        # Same {EXAC,BASE}, {PREC}- conversion
        convert(::Type{$TYPE{ùòÄ,ùòÖ,ùóØ}},
                y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),ùòÖ}(y)
        end
        # Same {BASE}, {PREC,EXAC}- conversion
        convert(::Type{$TYPE{ùòÄ,ùòÜ,ùóØ}},
                y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,ùòÜ<:EXAC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ)}(y)
        end
        # Promotion rules
        promote_rule(::Type{$TYPE{ùòÄ,ùòÜ,ùóØ}},
                     ::Type{$TYPE{ùóΩ,ùòÖ,ùóØ}}) where {ùòÄ<:PREC,ùóΩ<:PREC,
                                                  ùòÜ<:EXAC,ùòÖ<:EXAC,ùóØ<:BASE} = begin
            $TYPE{promote_type(ùòÄ,ùóΩ),promote_type(ùòÜ,ùòÖ),ùóØ}
        end
        # same-type sum,sub with Unitful promotion
        +(x::$TYPE{ùòÄ,ùòÜ,ùóØ}, y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,
                                                   ùòÜ<:EXAC,ùòÖ<:EXAC,
                                                   ùóØ<:BASE} = begin
            $TYPE(+(amt(x), amt(y)))
        end
        -(x::$TYPE{ùòÄ,ùòÜ,ùóØ}, y::$TYPE{ùóΩ,ùòÖ,ùóØ}) where {ùòÄ<:PREC,ùóΩ<:PREC,
                                                   ùòÜ<:EXAC,ùòÖ<:EXAC,
                                                   ùóØ<:BASE} = begin
            $TYPE(-(amt(x), amt(y)))
        end
        # scalar mul,div with Unitful promotion
        *(y::plnF{ùòÄ}, x::$TYPE{ùóΩ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        *(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(*(amt(x), y))
        /(x::$TYPE{ùóΩ}, y::plnF{ùòÄ}) where {ùòÄ<:PREC,ùóΩ<:PREC} = $TYPE(/(amt(x), y))
        # Type-preserving scalar mul,div
        *(y::REAL, x::$TYPE{ùóΩ}) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        *(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(*(amt(x), ùóΩ(y)))
        /(x::$TYPE{ùóΩ}, y::REAL) where ùóΩ<:PREC = $TYPE(/(amt(x), ùóΩ(y)))
    end
end


#----------------------------------------------------------------------------------------------#
#                           Thermodynamic Amount Group Declarations                            #
#----------------------------------------------------------------------------------------------#

# Anomalous primitives and products
mkBasAmt(:m_amt, :BProperty, :m_, :ùó∫ , "m" , u"kg"  , "kg"  , "mass"               , false, bsym=(:m  , :mÃá  , :mf, :M ))
mkBasAmt(:N_amt, :BProperty, :N_, :ùó° , "N" , u"kmol", "kmol", "chemical amount"    , false, bsym=(:N  , :NÃá  , :n , :y ))
mkBasAmt(:R_amt, :BProperty, :R_, :ùó• , "mR", u"kJ/K", "kJ/K", "gas constant"       , false, bsym=(:mR , :mÃáR , :R , :RÃÑ ))
mkBasAmt(:Pvamt, :BProperty, :Pv, :ùó£ùòÉ, "PV", u"kJ"  , "kJ"  , "flux work"          , false, bsym=(:PV , :PVÃá , :Pv, :PvÃÑ))
mkBasAmt(:RTamt, :BProperty, :RT, :ùó•ùóß, "RT", u"kJ"  , "kJ"  , "RT product"         , false, bsym=(:mRT, :mÃáRT, :RT, :RÃÑT))
mkBasAmt(:Tsamt, :BProperty, :Ts, :ùóßùòÄ, "Ts", u"kJ"  , "kJ"  , "Ts product"         , false, bsym=(:TS , :TSÃá , :Ts, :TsÃÑ))

# Regular properties
mkBasAmt(:v_amt, :BProperty, :v_, :ùòÉ , "V" , u"m^3" , "m¬≥"  , "volume"             , false)
mkBasAmt(:u_amt, :BProperty, :u_, :ùòÇ , "U" , u"kJ"  , "kJ"  , "internal energy"    , false)
mkBasAmt(:h_amt, :BProperty, :h_, :ùóµ , "H" , u"kJ"  , "kJ"  , "enthalpy"           , false)
mkBasAmt(:g_amt, :BProperty, :g_, :ùó¥ , "G" , u"kJ"  , "kJ"  , "Gibbs energy"       , false)
mkBasAmt(:a_amt, :BProperty, :a_, :ùóÆ , "A" , u"kJ"  , "kJ"  , "Helmholtz energy"   , false)
mkBasAmt(:e_amt, :BProperty, :e_, :ùó≤ , "E" , u"kJ"  , "kJ"  , "total energy"       , false)
mkBasAmt(:ekamt, :BProperty, :ek, :ùó≤ùó∏, "Ek", u"kJ"  , "kJ"  , "kinetic energy"     , false)
mkBasAmt(:epamt, :BProperty, :ep, :ùó≤ùóΩ, "Ep", u"kJ"  , "kJ"  , "potential energy"   , false)
mkBasAmt(:s_amt, :BProperty, :s_, :ùòÄ , "S" , u"kJ/K", "kJ/K", "entropy"            , false)
mkBasAmt(:cpamt, :BProperty, :cp, :ùó∞ùóΩ, "Cp", u"kJ/K", "kJ/K", "iso-P specific heat", false)
mkBasAmt(:cvamt, :BProperty, :cv, :ùó∞ùòÉ, "Cv", u"kJ/K", "kJ/K", "iso-v specific heat", false)
mkBasAmt(:c_amt, :BProperty, :c_, :ùó∞ , "C" , u"kJ/K", "kJ/K", "incompressible substance specific heat", false)
mkBasAmt(:j_amt, :BProperty, :j_, :ùó∑ , "J" , u"kJ/K", "kJ/K", "Massieu function"   , false)
mkBasAmt(:y_amt, :BProperty, :y_, :ùòÜ , "Y" , u"kJ/K", "kJ/K", "Planck function"    , false)

# Regular interactions
mkBasAmt(:q_amt, :BInteract, :q_, :ùóæ , "Q" , u"kJ"  , "kJ"  , "heat"               , false)
mkBasAmt(:w_amt, :BInteract, :w_, :ùòÑ , "W" , u"kJ"  , "kJ"  , "work"               , false)
mkBasAmt(:deamt, :BInteract, :de, :ùùôùó≤, "E" , u"kJ"  , "kJ"  , "energy variation"   , true )
mkBasAmt(:dsamt, :BInteract, :ds, :ùùôùòÄ, "S" , u"kJ/K", "kJ/K", "entropy variation"  , true )


#----------------------------------------------------------------------------------------------#
#                                      AMOUNT Type Unions                                      #
#----------------------------------------------------------------------------------------------#

# Unions of amounts of like units and thermodynamic classification, for same-unit operations

# --- energy
"""
`ENERGYP{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Energy property type union.
"""
ENERGYP{ùóΩ,ùòÖ,ùóØ} = Union{u_amt{ùóΩ,ùòÖ,ùóØ},h_amt{ùóΩ,ùòÖ,ùóØ},
                       g_amt{ùóΩ,ùòÖ,ùóØ},a_amt{ùóΩ,ùòÖ,ùóØ},
                       e_amt{ùóΩ,ùòÖ,ùóØ},ekamt{ùóΩ,ùòÖ,ùóØ},
                       epamt{ùóΩ,ùòÖ,ùóØ},Pvamt{ùóΩ,ùòÖ,ùóØ},
                       RTamt{ùóΩ,ùòÖ,ùóØ},Tsamt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`ENERGYI{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Energy interaction type union.
"""
ENERGYI{ùóΩ,ùòÖ,ùóØ} = Union{q_amt{ùóΩ,ùòÖ,ùóØ},w_amt{ùóΩ,ùòÖ,ùóØ},
                       deamt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`ENERGYA{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Energy amount type union.
"""
ENERGYA{ùóΩ,ùòÖ,ùóØ} = Union{ENERGYP{ùóΩ,ùòÖ,ùóØ},ENERGYI{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}


# --- entropy
"""
`NTROPYP{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Entropy property type union.
"""
NTROPYP{ùóΩ,ùòÖ,ùóØ} = Union{R_amt{ùóΩ,ùòÖ,ùóØ},y_amt{ùóΩ,ùòÖ,ùóØ},s_amt{ùóΩ,ùòÖ,ùóØ},
                       j_amt{ùóΩ,ùòÖ,ùóØ},c_amt{ùóΩ,ùòÖ,ùóØ},
                       cpamt{ùóΩ,ùòÖ,ùóØ},cvamt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`NTROPYI{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Entropy interaction type union.
"""
NTROPYI{ùóΩ,ùòÖ,ùóØ} = Union{dsamt{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}

"""
`NTROPYA{ùóΩ,ùòÖ,ùóØ} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}`\n
Entropy amount type union.
"""
NTROPYA{ùóΩ,ùòÖ,ùóØ} = Union{NTROPYP{ùóΩ,ùòÖ,ùóØ},NTROPYI{ùóΩ,ùòÖ,ùóØ}} where {ùóΩ<:PREC,ùòÖ<:EXAC,ùóØ<:BASE}


# --- velocity
"""
`VELOCYP{ùóΩ,ùòÖ} where {ùóΩ<:PREC,ùòÖ<:EXAC}`\n
Velocity property type union.
"""
VELOCYP{ùóΩ,ùòÖ} = Union{veamt{ùóΩ,ùòÖ},spamt{ùóΩ,ùòÖ},csamt{ùóΩ,ùòÖ}} where {ùóΩ<:PREC,ùòÖ<:EXAC}


# --- dimensionless
"""
`DIMLESS{ùóΩ,ùòÖ} where {ùóΩ<:PREC,ùòÖ<:EXAC}`\n
Dimensionless amount type union.
"""
DIMLESS{ùóΩ,ùòÖ} = Union{√∏_amt{ùóΩ,ùòÖ},Z_amt{ùóΩ,ùòÖ},gaamt{ùóΩ,ùòÖ},k_amt{ùóΩ,ùòÖ},
                     Maamt{ùóΩ,ùòÖ},Pramt{ùóΩ,ùòÖ},vramt{ùóΩ,ùòÖ}} where {ùóΩ<:PREC,ùòÖ<:EXAC}


#----------------------------------------------------------------------------------------------#
#                                       Pretty Printing                                        #
#----------------------------------------------------------------------------------------------#

import Base: show

# Auxiliary methods
function subscript(x::Int)
    asSub(c::Char) = Char(Int(c) - Int('0') + Int('‚ÇÄ'))
    map(asSub, "$(x)")
end

function valFmt(x::ùóΩ, sigD = DEF[:showSigD]) where ùóΩ<:PREC
    y = Float64(x)
    buffr = repeat([0x0, ], 1024+14)
    bytes = ccall(
        :sprintf, Int32, (Ptr{UInt8}, Cstring, Int64, Float64),
        buffr, "%#.*g", sigD, y)
    return bytes < length(buffr) ? unsafe_string(pointer(buffr)) : "#VALUE!"
end

# Precision decoration
pDeco(::Type{Float16})  = DEF[:showPrec] ? subscript(16) : ""
pDeco(::Type{Float32})  = DEF[:showPrec] ? subscript(32) : ""
pDeco(::Type{Float64})  = DEF[:showPrec] ? subscript(64) : ""
pDeco(::Type{BigFloat}) = DEF[:showPrec] ? subscript(precision(BigFloat)) : ""

# Custom printing
Base.show(io::IO, x::AMOUNTS{ùóΩ,EX}) where ùóΩ<:PREC = begin
    if DEF[:pprint]
        print(io,
            "$(string(deco(x)))$(pDeco(ùóΩ)): ",
            valFmt(amt(x).val),
            ppu(x) == "" ? "" : " $(ppu(x))"
        )
    else
        print(io,
            "$(typeof(x))(",
            valFmt(amt(x).val),
            ppu(x) == "" ? ")" : " $(ppu(x)))"
        )
    end
end

Base.show(io::IO, x::AMOUNTS{ùóΩ,MM}) where ùóΩ<:PREC = begin
    if DEF[:pprint]
        print(io,
            "$(string(deco(x)))$(pDeco(ùóΩ)): (",
            valFmt(amt(x).val.val),
            " ¬± ",
            valFmt(amt(x).val.err, 2),
            ppu(x) == "" ? "" : " $(ppu(x)))"
        )
    else
        print(io,
            "$(typeof(x))(",
            valFmt(amt(x).val.val),
            " ¬± ",
            valFmt(amt(x).val.err, 2),
            ppu(x) == "" ? ")" : " $(ppu(x)))"
        )
    end
end


#  L5TYP  FINT    SY
#  ------------------
#  __amt    _a     _
#  T_amt    T_     T
#  P_amt    P_     P
#  veamt    ve     ùïç
#  spamt    sp     ùïß
#  t_amt    t_     t
#  gvamt    gv     ùíà
#  z_amt    z_     z
#  Z_amt    Z_     Z
#  gaamt    ga     Œ≥
#  beamt    be     Œ≤
#  kTamt    kT    Œ∫T
#  ksamt    ks    Œ∫s
#  k_amt    k_     k
#  csamt    cs    cs
#  Maamt    Ma    Ma
#  mJamt    mJ    ŒºJ
#  mSamt    mS    ŒºS
#  x_amt    x_     x
#  Pramt    Pr    Pr
#  vramt    vr    vr
#  √∏_amt    √∏_     √∏
#  m_amt    m_    **
#  N_amt    N_    **
#  R_amt    R_    **
#  Pvamt    Pv    **
#  RTamt    RT    **
#  Tsamt    Ts    **
#  v_amt    v_     v
#  u_amt    u_     u
#  h_amt    h_     h
#  g_amt    g_     g
#  a_amt    a_     a
#  e_amt    e_     e
#  ekamt    ek    ek
#  epamt    ep    ep
#  s_amt    s_     s
#  cpamt    cp    cp
#  cvamt    cv    cv
#  c_amt    c_     c
#  j_amt    j_     j
#  y_amt    y_     y
#  q_amt    q_     q
#  w_amt    w_     w
#  deamt    de    Œîe
#  dsamt    ds    Œîs

